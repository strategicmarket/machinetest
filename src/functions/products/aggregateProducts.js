import { z } from 'zod';
import { Tool } from '@/catalog/tool';
import { APPROVED_OPERATORS } from '@/constants'

const aggregateProductsSchema = z.object({
  query: z.array(z.object({}).catchall(z.any())), // Defines a schema for aggregation queries
});

// Simplified validation function focusing on operators
function traverseAndValidate(node, errors = [], path = '') {
  if (Array.isArray(node)) {
    node.forEach((item, index) => traverseAndValidate(item, errors, `${path}[${index}]`));
  } else if (typeof node === 'object' && node !== null) {
    Object.entries(node).forEach(([key, value]) => {
      const currentPath = path ? `${path}.${key}` : key;
      if (key.startsWith('$')) {
        if (!APPROVED_OPERATORS.includes(key)) {
          errors.push(`Unapproved operator used: ${currentPath}`);
        }
      }
      // Recurse for nested objects and arrays without field name validation
      if (typeof value === 'object') {
        traverseAndValidate(value, errors, currentPath);
      }
    });
  }
  return errors;
}

const toolName = 'aggregate_products';
const toolDescription = 'Process MongoDB aggregation commands generated by AI, after validation against defined criteria';

const aggregateProducts = async (params) => {
  try {
    // Validate the structure of the query    
    aggregateProductsSchema.parse(params);

    // Perform custom operator validation
    const errors = traverseAndValidate(params.query);

    if (errors.length > 0) {
      // Return errors to the calling function
      return { success: false, errors };
    }

    const response = await fetch('/api/tools/aggregateProducts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(params.query),
    });

    if (!response.ok) {
      return { success: false, message: 'Failed to fetch products' };
    }

    const result = await response.json();
    return { success: true, data: result.data };

  } catch (error) {
    // Handle all errors in a unified manner
    console.error("Error during aggregation processing:", error);
    return { success: false, message: `Error during aggregation processing: ${error.message || 'Unknown error'}` };
  }
};

// Creating the tool instance
const aggregateProductsTool = Tool(
  aggregateProductsSchema,
  toolName,
  toolDescription,
  aggregateProducts
);

export { aggregateProductsTool as aggregateProducts };
